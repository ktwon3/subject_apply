업데이트 : 6/11
1. student_class.py : Student 클래스를 담당하는 파일
Student : 인스턴스에 각각의 선호 시간표를 가지고 있음
self.subject : 인스턴스 학생이 들을 과목들을 순서에 상관 없이 리스트에 저장
return_sub() : self.subject에 무엇이 들어있는지 알아보기 위한 메소드 (디버깅 용도)
set_apply_order() : 학생의 선호시간표를 작성하기 위한 메소드
간략 설명 : 과제연구 우선 고정, 이후 랜덤으로 과목 골라 고정, 이후 랜덤으로 배치

self.count_fixed : 고정 과목 수 (반드시 그 시간에 들어야 하는 과목 수)
self.ideal_subject : 학생의 이상적인, 즉 선호 시간표
apply()와 check_result() : 디버깅 용도 self.fix_same는 apply() 이후 몇개의 고정과목 수강신청을 성공했는지 저장


2. utill.py : 다양한 기능을 담당하는 함수를 모아둔 파일

set_remain_subject : 여러 함수에서 쓰일 remain_subject를 생성하는 파일, subject_block.txt에 들어있는 데이터로 만듦
공강 총 학생수 : 전 학생, 과제연구 분반당 학생수 : 13 (정보전산 3반 기준), 필수 과목 분반당 학생수 : 26, 나머지 : 24 (인터뷰 기반)
remain_subject는 각 인덱스는 과목 번호, 인덱스 속 딕셔너리의 key는 분반, value는 [블럭, 더 들어갈 수 있는 수강생 수]임
예를 들어 remain_subejct = [... {1:[2,10], 2:[5:3]} ... ] 이고 명시된 딕셔너리의 리스트 속 인덱스가 10이라면
10번 과목 (화1)의 1분반은 2블럭에 10명 더 신청 가능, 2분반은 5블럭에 3명 더 신청 가능하다는 뜻
parameter >> x
return >> remain_subject

print_remain_sub : remain_subject를 보기 좋게 출력해줌
parameter >> remain_subject
return >> x (함수 내에서 출력)

set_remain_block : remain_subject를 pick()에서 쓰기 좋도록 block별로 정리해놓은 딕셔너리를 반환하는 함수
remain_block : {블럭 : [{'subject' : (과목 번호), 'class_num' : (분반), 'remain_student' : (남은 학생수)}, ...], 블럭 : ...}
예를 들어 {... , 8: [{'subject': 20, 'class_num': 8, 'remain_student': 0}, {'subject': 24, 'class_num': 4, 'remain_student': 0}], 9: ...}
이면 8블럭엔 과목번호 20이 8분반에 남은 인원 0명, 과목번호 24가 4분반에 남은 인원 0명이라는 뜻
parameter >> rs : remain_subject, necessary_sub : 필수 과목들 (2021 2학년 1학기 : 수I과 운건) 리스트
return >> remain_block

print_remain_block : remain_block을 보기 좋게 출력해줌
parameter >> rb : remain_block
return >> x (함수 내에서 출력)

save_file : pickle 모듈을 활용해서 데이터 그대로 txt파일에 저장
parameter >> file_name, data : 저장할 데이터
return >> x

add_overlab_block : 7과 10,12 // 8과 11,13 블럭과 같이 중복되는 블록 배제하기 위한 함수, apply()에서 쓰임
parameter >> b : 중복되는지 체크될 블럭 cb : chose_block, 이미 신청한 블록
return >> chose_b : 중복되었을 경우 cb에 b를 append하여 반환

label_sub : 각 과목번호에 이름을 붙이는 함수 (디버깅 용도)
sub__name.txt에서 과목 이름을 받아옴
[1,2,3] => {1: '중국어 문법', 2: '일본어 문법', 3: '선대'}와 같이 변환
sub__name.txt가 엑셀에서 복사/붙여넣기를 한거라 파일 전처리 과정이 복잡함 주의
parameter >> sub_list : 이름을 붙이고 싶은 과목번호들의 '리스트'
return : return_dic : key가 과목 번호, value가 과목 이름인 딕셔너리

<고정 변수>
SPC : Student Per Class, 일반적인 분반당 학생수, 현재는 24로 고정
NOSD : Number Of StuDent, 총 학생수
NOB : Number Of Block, 수강 신청을 해야하는 블럭 개수 (공강과 과제연구가 포함됨 주의)
NOSJ : Number Of SubJect, 공강을 합친 과목 종류의 수


pick_subject.py : 블럭만 보고 랜덤으로 학생들의 과목을 배정하는 과정을 담은 파일

pick_onetime : 과목 배정 한 사이클을 수행하는 함수
학생 한 명에 대한 과목 배정 알고리즘
1. 1~13 블럭 중 랜덤으로 선택 (중복으로 가져오진 x)
2. 해당 블럭의 remain_block 전처리 (랜덤으로 섞기, 필수과목 앞으로 가져오기)
3. remain_block에서 첫번째부터 조건에 맞는지 확인
4. 조건에 맞는 딕셔너리를 찾으면 chose_subject, chose_block에 해당 딕셔너리의 정보를 기입, 그 분반의 남은 인원 -1, track 재탐색
5. NOB개 신청을 완료 or 블럭 전부 서치 완료 => 6단계 else 1단계로
6. NOB - 1 미만 신청 : 실패, NOB -1 개 신청 : 공강 추가 신청, NOB개 신청 : 성공

4단계 조건 : 해당 과목이 중복인가?, 해당 분반의 남은 인원수가 남아있는가? 공강은 아닌가?
블록 중복에 안 걸리는가? 과제연구는 1개 이하인가? track에 위배되진 않는가?
단 위 질문과 pick_onetime의 코드는 반대임 (코드 내에선 거짓이면 4단계로 가는 구조)

parameter >> re_sub(필요 없음), nosj(필요 없음), nosd, nob, student : Student 클래스, necessary_sub
return >> 성공/실패 여부, (성공시엔) students: Student 객체들의 리스트 // (실패시엔) n : 몇 번째 학생에서 실패

pick : pick_onetime()을 성공할때까지 반복
실패시 n 출력
parameter >> re_sub, nosj, nosd, nob, student : class
return >> result : Student 객체들의 리스트, try_count : 몇 번만에 성공

sort_necessary : pick_onetime의 2단계 '필수과목 앞으로 가져오기'를 수행하는 함수
parameter >> dic_list : remain_block의 특정 블럭의 딕셔너리를 모아놓은 리스트 (remain_block[i]), necessary_list : 필수과목 번호리스트
return >> result : 필수과목을 앞으로 가져온 리스트

confirm_pick : 각 과목 신청자수 리스트로 반환
parameter >> stu : Student의 객체 리스트, nosj : Number Of SubJect
return >> result : [2,5,10] 이면 0번 과목 2명, 1번 과목 5명, 2번 과목 10명 신청했단 뜻

measure_pick_time : pick()이 몇번만에 끝나는지 평균
parameter >> resub : remain_subject, nosj, nosd, nob, student : class, n : pick()을 몇번해서 평균낼건지
return : sum_/n : 평균값

set_track : 과목 리스트의 트랙을 정하는 함수
실제 트랙과 동일하게 적용, 물론 공강과 과제연구는 트랙 고려에서 제외 (자세한건 연구노트)
parameter >> chose_bloc : chose_block, chose_sub : chose_sub, track
return >> track

check_condition : 4단계 조건의 3,4,5 (블록 중복에 안 걸리는가? 과제연구는 1개 이하인가? track에 위배되진 않는가?) 체크
parameter >> b : 현재 신청할 블럭, chose_b : chose_block (신청한 블록), chose_subject : 신청한 과목, track, sub : 신청할 과목
return >> False -> 신청 가능 True -> 신청 불가능

check_track: 트랙 위배 체크
parameter >> b, track, chose_block, chose_sub (check_condition과 동일)
return : False -> 위배x True -> 위배

check_overlab_research : 과제연구 중복 체크
parameter >> sub, chose_subject (check_condition과 동일)
return : False -> 중복 x True -> 중복

check_overlap_block() : 블록 중복 체크 (8,11,13//7,10,12)
parameter >> b, chose_b (check_condition과 동일)
return : False -> 중복 x True -> 중복



apply_subject.py : 3차 수강신청 구현

apply : 3차 수강신청을 해주는 함수

전체 알고리즘
1. 학생 순서를 섞음
2. 수강 신청 완료가 안 된 사람 중에서 차례로 한명씩 뽑아옴
3. 블록 중복 고려
4. applied_sub_list에서 이미 신청한 과목 받아옴
5-1 선호 시간표대로 신청 가능할 때 : 블록 중복이 없고 사람이 안 꽉 찼으면 선호 시간표에 맞춰 신청
5-2 불가능 : 남은 과목 랜덤 선택 -> 분반 리스트에서 블록 중복이 있거나 사람이 꽉 찼으면 삭제 -> 남은 분반중 하나 골라 리스트에 추가
6. 1~5단계를 time번 반복

parameter >> stud : Student 객체 리스트, nosd, nob, time : 1~5단계 반복할 횟수, fix : 고정 과목이 있으면 (신청 가능하면) True
return >> result_ : [{블럭 : [과목, 분반], 블럭 : [과목, 분반] ... }, {...}, ...]
ex) result_ = [{4 : [1,1], 2 : [20,2]}, ...] 이면 첫번째 학생은 4번째 블럭의 1번과목 1분반, 2번째 블럭의 20번과목 2분반 신청 완료

check_applying_result : apply 이후 신청 성공한 블럭 몇갠지 return (디버깅 용도)
parameter >> resul : apply의 결과, nob
return >> {..., 6: 0, 7: 2, 8: 35, 9: 89, 10: 78} 6블럭 성공 0명, 7블럭 성공 2명, 8블록 성공 35명, 9블록 성공 89명, 10블록 성공 78명

find_block_student : check_applying_result의 key 하나 출력 (디버깅 용도)
parameter >> resul : apply의 결과, bloc_num : 가져올 key
return >> bloc_num개의 블록 신청 성공한 사람

repeat_find_block_student : find_block_student를 반복 (디버깅 용도)
parameter >> bloc_num : 몇개의 블록으로 조사할건지, time : 반복 횟수, students : Student 객체 리스트, fix=False : 고정과목 유무
return >> r : 각 인덱스의 학생이 얼마나 bloc_num개의 블록만 수강신청 했는지

find_repeating_max : repeat_find_block_student에서 최소와 최대 찾는 함수 (디버깅 용도)
parameter >> bloc_num, time, students, fix=False (전부 위와 동일)
return >> result : key가 'max'와 'min'이고 value가 각각 최대 학생, 최소 학생

frm_print : find_repeating_max를 보기 좋게 출력 (디버깅 용도)
parameter >> find_repeating_max와 동일
return >> x (출력 형태)
